= ReactiveX mit Angular und Android
Anton Cao
1.0, {docdate}
ifndef::sourcedir[:sourcedir: ../src/main/java]
ifndef::imagesdir[:imagesdir: images]
ifndef::backend[:backend: html5]
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc:
:source-highlighter: rouge
:docinfo: shared

== ReactiveX

ReactiveX (Reactive Extensions) ist eine API für asynchrone und eventbasierte Programmierung mithilfe von **Observables**.
Das Hauptproblem, das ReactiveX löst, ist der Umgang mit asynchronen Datenströmen in einer verständlichen, flexiblen und fehlerresistenten Weise.

=== Asynchron

image::asynchron.png[]

Bei der **synchronen** Weise werden sie hintereinander ausgeführt. Das heißt, nachdem der Prozess A eine I/O Operation
(z.B. HTTP-Request) sendet, wird sozusagen die Anwendung **blockiert**. Der Prozess A wartet, bis der Prozess B eine
Antwort sendet. In der Zeit führt der Prozess A keine weiteren Aufgaben durch.

Bei der **asynchronen** Weise wird der Prozess A nicht blockiert, nachdem er eine I/O Operation gesendet hat. In der
Zwischenzeit führt der Prozess A seine nächsten Aufgaben durch, währenddessen Prozess B seine Aufgaben durchführt.

=== Observable

Ein Observable ist ein Objekt, das asynchrone Datenströme bereitstellt. Es repräsentiert eine Quelle, die im Laufe
der Zeit Daten (z. B. Ereignisse, API-Antworten oder Benutzereingaben) senden kann.

Nicht zu verwechseln mit **Observer** (Subscriber)!
Ein Observer ist ein Objekt, das auf die Daten reagiert, die von einem Observable gesendet werden.
Es definiert, wie mit den gesendeten Daten umgegangen wird.

Eigenschaften des Observers:

- **next:** Sendet Daten.
- **error:** Signalisiert einen Fehler.
- **complete:** Signalisiert das Ende des Streams.

Beispiel:

```typescript
import { Observable } from 'rxjs';

const observable = new Observable(subscriber => {
  subscriber.next('Daten 1');
  subscriber.next('Daten 2');
  setTimeout(() => {
    subscriber.next('Daten 3');
    subscriber.complete();
  }, 1000);
});

observable.subscribe({
  next: value => console.log(value),
  complete: () => console.log('Fertig!'),
});
```

== Alternative

Es gibt verschiedene Alternativen zu ReactiveX, die ähnliche Funktionalitäten für asynchrone Programmierung bieten:

- **https://github.com/reactor/reactor-core[Reactor Core]**
- **https://smallrye.io/smallrye-mutiny/latest/[Mutiny]**
- **https://kotlinlang.org/docs/coroutines-overview.html[Kotlin Coroutines]**
- **https://vertx.io/[Vert.x]**

== Quarkus Mutiny vs andere reaktive API

[quote, Quarkus]
____
Mutiny is the primary API when dealing with the reactive features from Quarkus. It means that most extensions support
Mutiny either by exposing an API returning Unis and Multis (such as reactive data sources or rest clients)
or understanding when your methods return a Uni or a Multi (such as Quarkus REST (formerly RESTEasy Reactive)
or Reactive Messaging).
____
https://quarkus.io/guides/mutiny-primer[Quarkus Mutiny]

Kurz zusammengefasst: Quarkus verwendet primär die Mutiny-API für reaktive Applikationen. Viele Extensions wie:

----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-hibernate-reactive</artifactId>
</dependency>
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-reactive-pg-client</artifactId>
</dependency>
----

verlangen Typen wie **Uni** oder **Multi**. Es würde dann zum Konflikt zwischen den Typen von anderen reaaktiven API wie
**RxJava** oder **Vert.x** kommen.



== Quelle

- https://reactivex.io/intro.html
- https://blog.logrocket.com/guide-rxjs-observables/
- https://www.ramotion.com/blog/synchronous-vs-asynchronous-programming/
- https://tektutorialshub.com/angular/angular-observable-tutorial-using-rxjs/#google_vignette
e_vignette