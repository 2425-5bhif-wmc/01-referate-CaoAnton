= ReactiveX mit Angular und Android
Anton Cao
1.0, {docdate}
ifndef::sourcedir[:sourcedir: ../src/main/java]
ifndef::imagesdir[:imagesdir: images]
ifndef::backend[:backend: html5]
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc:
:source-highlighter: rouge
:docinfo: shared

== ReactiveX

ReactiveX (Reactive Extensions) ist eine API für asynchrone und eventbasierte Programmierung mithilfe von **Observables**.
Das Hauptproblem, das ReactiveX löst, ist der Umgang mit asynchronen Datenströmen in einer verständlichen, flexiblen und fehlerresistenten Weise.

=== Asynchron

image::asynchron.png[]

Bei der **synchronen** Weise werden sie hintereinander ausgeführt. Das heißt, nachdem der Prozess A eine I/O Operation
(z.B. HTTP-Request) sendet, wird sozusagen die Anwendung **blockiert**. Der Prozess A wartet, bis der Prozess B eine
Antwort sendet. In der Zeit führt der Prozess A keine weiteren Aufgaben durch.

Bei der **asynchronen** Weise wird der Prozess A nicht blockiert, nachdem er eine I/O Operation gesendet hat. In der
Zwischenzeit führt der Prozess A seine nächsten Aufgaben durch, währenddessen Prozess B seine Aufgaben durchführt.

=== Observable

Ein Observable ist ein Objekt, das asynchrone Datenströme bereitstellt. Es repräsentiert eine Quelle, die im Laufe
der Zeit Daten (z. B. Ereignisse, API-Antworten oder Benutzereingaben) senden kann.

Nicht zu verwechseln mit **Observer** (Subscriber)!
Ein Observer ist ein Objekt, das auf die Daten reagiert, die von einem Observable gesendet werden.
Es definiert, wie mit den gesendeten Daten umgegangen wird.

Eigenschaften des Observers:

- **next:** Sendet Daten.
- **error:** Signalisiert einen Fehler.
- **complete:** Signalisiert das Ende des Streams.

Beispiel:

```typescript
import { Observable } from 'rxjs';

const observable = new Observable(subscriber => {
  subscriber.next('Daten 1');
  subscriber.next('Daten 2');
  setTimeout(() => {
    subscriber.next('Daten 3');
    subscriber.complete();
  }, 1000);
});

observable.subscribe({
  next: value => console.log(value),
  complete: () => console.log('Fertig!'),
});
```

== Alternative

Es gibt verschiedene Alternativen zu ReactiveX, die ähnliche Funktionalitäten für asynchrone Programmierung bieten:

- **https://github.com/reactor/reactor-core[Reactor Core]**
- **https://smallrye.io/smallrye-mutiny/latest/[Mutiny]**
- **https://kotlinlang.org/docs/coroutines-overview.html[Kotlin Coroutines]**
- **https://vertx.io/[Vert.x]**

== Quarkus Mutiny vs andere reaktive API

[quote, Quarkus]
____
Mutiny is the primary API when dealing with the reactive features from Quarkus. It means that most extensions support
Mutiny either by exposing an API returning Unis and Multis (such as reactive data sources or rest clients)
or understanding when your methods return a Uni or a Multi (such as Quarkus REST (formerly RESTEasy Reactive)
or Reactive Messaging).
____
https://quarkus.io/guides/mutiny-primer[Quarkus Mutiny]

Kurz zusammengefasst: Quarkus verwendet primär die Mutiny-API für reaktive Applikationen. Viele Extensions wie:

----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-hibernate-reactive</artifactId>
</dependency>
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-reactive-pg-client</artifactId>
</dependency>
----

verlangen Typen wie **Uni** oder **Multi**. Es würde dann zum Konflikt zwischen den Typen von anderen reaaktiven API wie
**RxJava** oder **Vert.x** kommen.

== Beispiele mit ReactiveX

[plantuml]
----
include::puml/architecture.puml[]
----

Es befinden sich im Repository zwei Beispiele mit ReactiveX:

* Angular mit RxJS
* Android mit RxJava

Um Daten zu bekommen, wurde eine Fake-REST-API von https://jsonplaceholder.typicode.com/[jsonplaceholder] verwendet. Sie
gibt ToDos zurück und so sieht die Struktur aus:

[plantuml]
----
include::puml/todos.puml[]
----

== Angular (rxjs-demo)

[plantuml]
----
!$highlight_component = "rxjs"
include::puml/architecture.puml[]
----


RxJS ist eine reaktive Bibliothek, die mit Angular verwendet wird, um asynchrone Datenströme wie API-Aufrufe,
Benutzereingaben und Ereignisse zu verwalten. Ein wichtiges Konzept hierbei ist die **Single Source of Truth (SSOT)**.

=== Single Source of Truth

Das SSOT-Prinzip bedeutet, dass alle Daten aus einer zentralen Quelle stammen.
Mit RxJS wird diese Quelle typischerweise durch Observables oder Subjects repräsentiert.


== RxJava in Android

[plantuml]
----
!$highlight_component = "rxjava"
include::puml/architecture.puml[]
----

RxJava ist eine Implementierung von ReactiveX für die JVM und wird häufig in Android-Apps verwendet, um asynchrone Operationen wie Netzwerkaufrufe, Datenbankzugriffe und Benutzerinteraktionen zu verwalten.



== Quelle

- https://reactivex.io/intro.html
- https://blog.logrocket.com/guide-rxjs-observables/
- https://www.ramotion.com/blog/synchronous-vs-asynchronous-programming/
- https://tektutorialshub.com/angular/angular-observable-tutorial-using-rxjs/#google_vignette
e_vignette