= ReactiveX mit Angular und Android
Anton Cao
1.0, {docdate}
ifndef::sourcedir[:sourcedir: ../src/main/java]
ifndef::imagesdir[:imagesdir: images]
ifndef::backend[:backend: html5]
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc:
:source-highlighter: rouge
:docinfo: shared

== ReactiveX

ReactiveX (Reactive Extensions) ist eine API für asynchrone und eventbasierte Programmierung mithilfe von **Observables**.
Das Hauptproblem, das ReactiveX löst, ist der Umgang mit asynchronen Datenströmen in einer verständlichen, flexiblen und fehlerresistenten Weise.

=== Asynchron

image::asynchron.png[]

Bei der **synchronen** Weise werden sie hintereinander ausgeführt. Das heißt, nachdem der Prozess A eine I/O Operation
(z.B. HTTP-Request) sendet, wird sozusagen die Anwendung **blockiert**. Der Prozess A wartet, bis der Prozess B eine
Antwort sendet. In der Zeit führt der Prozess A keine weiteren Aufgaben durch.

Bei der **asynchronen** Weise wird der Prozess A nicht blockiert, nachdem er eine I/O Operation gesendet hat. In der
Zwischenzeit führt der Prozess A seine nächsten Aufgaben durch, währenddessen Prozess B seine Aufgaben durchführt.

=== Observable

Ein Observable ist ein Objekt, das asynchrone Datenströme bereitstellt. Es repräsentiert eine Quelle, die im Laufe
der Zeit Daten (z. B. Ereignisse, API-Antworten oder Benutzereingaben) senden kann.

Nicht zu verwechseln mit **Observer** (Subscriber)!
Ein Observer ist ein Objekt, das auf die Daten reagiert, die von einem Observable gesendet werden.
Es definiert, wie mit den gesendeten Daten umgegangen wird.

image::observable.jpg[]

Eigenschaften des Observers:

- **next:** Sendet Daten.
- **error:** Signalisiert einen Fehler.
- **complete:** Signalisiert das Ende des Streams.

Beispiel:

[source, typescript]
----
import { Observable } from 'rxjs';

const observable = new Observable((subscriber) => {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  setTimeout(() => {
    subscriber.next(4);
    subscriber.complete();
  }, 1000);
});

console.log('just before subscribe');
observable.subscribe({
  next(x) {
    console.log('got value ' + x);
  },
  error(err) {
    console.error('something wrong occurred: ' + err);
  },
  complete() {
    console.log('done');
  },
});
console.log('just after subscribe');
----

.Output
[%collapsible]
====
----
just before subscribe
got value 1
got value 2
got value 3
just after subscribe
got value 4
done
----
====

image::observable-exmaple.png[]

== Alternative

Es gibt verschiedene Alternativen zu ReactiveX, die ähnliche Funktionalitäten für asynchrone Programmierung bieten:

- **https://github.com/reactor/reactor-core[Reactor Core]**: wird häufig in Java Spring verwendet
- **https://smallrye.io/smallrye-mutiny/latest/[Mutiny]**: wird primär in Quarkus verwendet
- **https://vertx.io/[Vert.x]**: für Java oder Kotlin verwendet

== Quarkus Mutiny vs andere reaktive API


Quarkus verwendet primär die Mutiny-API für reaktive Applikationen. Viele der eingebauten Extensions wie:
verlangen Typen wie **Uni** oder **Multi**. Es würde dann zum Konflikt zwischen den Typen von anderen reaaktiven API wie
**RxJava** oder **Vert.x** kommen. https://quarkus.io/guides/mutiny-primer[Quarkus Mutiny]

[cols="3,3,3", options="header"]
|===
|Merkmal                     |Mutiny                                     |RxJava

|**Single-Item Stream**      |`Uni<T>`                                   |`Single<T>` / `Maybe<T>`
|**Multi-Item Stream**       |`Multi<T>`                                 |`Observable<T>` / `Flowable<T>`
|**Fehlerbehandlung**        |`onFailure().recoverWithItem()`             |`onErrorResumeNext()`
|**Ressourcenverbrauch**     |Gering (optimiert für Quarkus)             |Höher, allgemeiner Einsatz
|**Integration**             |Nahtlos mit Quarkus Extensions             |Framework-unabhängig
|**Zielsetzung**             |Cloud-native, reaktive Microservices       |Allgemeine reaktive Programmierung
|**Sprachunterstützung**     |Java                                       |Java, Kotlin
|===



== Beispiele mit ReactiveX

[plantuml]
----
include::puml/architecture.puml[]
----

Es befinden sich im Repository zwei Beispiele mit ReactiveX:

* Angular mit RxJS
* Android mit RxJava

Um Daten zu bekommen, wurde eine Fake-REST-API von https://jsonplaceholder.typicode.com/[jsonplaceholder] verwendet. Sie
gibt ToDos zurück und die Struktur sieht so aus:

[plantuml]
----
include::puml/todos.puml[]
----

== Android (rxjava-demo)

[plantuml]
----
!$highlight_component = "rxjava"
include::puml/architecture.puml[]
----

RxJava ist eine Implementierung von ReactiveX für die JVM und wird häufig in Android-Apps verwendet, um asynchrone
Operationen wie  Datenbankzugriffe und Benutzerinteraktionen zu verwalten.

=== Android-MVVM

image::android-mvvm-pattern.png[]

* Model:
** Repräsentiert die Daten und Geschäftslogik der Anwendung
**
* ViewModel:
** verbindet die Model und die View
** Holt Daten aus dem Model, verarbeitet sie und stellt sie der View bereit.
** Sendet Datenstreams an die View und empfängt Daten von ihr.
** Beobachtet Änderungen im Model und leitet diese an die View weiter.
* View:
** Reagiert auf Benutzerinteraktionen (z.B. Klicks) und sendet diese an das ViewModel
** Beobachtet Datenänderungen aus dem ViewModel und aktualisiert die UI entsprechend

=== Drei Prinzipien

https://redux.js.org/understanding/thinking-in-redux/three-principles[Three Principles]

* Single Source of Truth
* State is Read-Only
* Changes are Made with Pure Functions

==== Single Source of Truth

* Der gesamte Zustand der Anwendung wird in einem einzigen, zentralen Store gespeichert.
* RxJava mit BehaviorSubject

==== State is Read-Only

* Der Zustand kann nicht direkt geändert werden. Änderungen erfolgen nur durch das Auslösen von Actions.
* Änderungen am Zustand erfolgen durch definierte Methoden im ViewModel.
* Mit RxJava erfolgt die Änderung des Zustands über Events oder Streams (z.B. durch onNext() in einem Subject).

==== Changes are Made with Pure Functions

* Änderungen des Zustands erfolgen durch reine Funktionen (Reducers), die keine Seiteneffekte haben.
* Methoden im ViewModel sollten idealerweise rein sein: Sie verändern nicht direkt die View oder äußere Zustände.

=== Projekt



* Feature:
* Model:
* Util:


==== Util

.store
[%collapsible]
====
.StoreBase.java
[source, java]
----
include::../../android-mvvm/app/src/main/java/at/htl/leonding/util/store/StoreBase.java[]
----
====

.immer
[%collapsible]
====
.Immer.java
[source, java]
----
include::../../android-mvvm/app/src/main/java/at/htl/leonding/util/immer/Immer.java[]
----
====

.mapper
[%collapsible]
====
* dient zur zur Serialisierung und Deserialisierung von Objekten nach JSON und zurück.
* führt er tiefe Klonoperationen aus.
====


.resteasy
[%collapsible]
====

====

.config
[%collapsible]
====

====

==== Model

.Model.java
[%collapsible]
====

====


.Store.java
[%collapsible]
====

====

.ToDo.java
[%collapsible]
====

====

.UIState.java
[%collapsible]
====

====


==== Feature

* Fokus auf example und todo

.example
[%collapsible]
====

====

.todo
[%collapsible]
====

====

== Angular (rxjs-demo)

[plantuml]
----
!$highlight_component = "rxjs"
include::puml/architecture.puml[]
----

RxJS ist eine reaktive Bibliothek, die speziell in Angular verwendet wird, um asynchrone Datenströme wie API-Aufrufe,
Benutzereingaben und Ereignisse zu verwalten.

=== Struktur des Projekts

image::angular-project.png[]

==== Model

.model.ts
[source, typescript]
----
include::../../rxjs-demo/src/app/model/model.ts[]
----

<.> definiert das Modell
<.> der anfängliche Zustand des Modells
<.> das zentrale Element in der Anwendung (Single Source Of Truth)


== Quelle

- https://reactivex.io/intro.html
- https://blog.logrocket.com/guide-rxjs-observables/
- https://www.ramotion.com/blog/synchronous-vs-asynchronous-programming/
- https://www.tektutorialshub.com/angular/angular-observable-tutorial-using-rxjs/
- https://www.digitalocean.com/community/tutorials/android-mvvm-design-pattern